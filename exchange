 #ifndef MOD_NOTIFICATIONS_H
#define MOD_NOTIFICATIONS_H
#include "../AbstractModuleBase.h"
#include "SceneryManager/scenario.h"
#include "SceneryManager/notificationtrigger.h"

/*
 questi includes sono stati aggiunti per testare esecuzioneI/O (su websocket_client funziona mentre su scheduler no)
 */
#include <QtCore/QObject>
#include <QtWebSockets/QWebSocket>
#include <QtNetwork/QSslError>
#include <QtCore/QList>
#include <QtCore/QString>
#include <QtCore/QUrl>
#include <QObject>
#include "./Gui/guicommserver.h"
#include "Modules/mod_guiserver.h"
#include "Modules/fieldmap/mod_fieldmap.h"
#include "def_queues.h"
#include "Modules/App_Automations/mod_appautomations.h"
#include "Modules/App_Scenery/mod_scenery.h"
#include "def_hwtypes.h"
#include "def_objects.h"
#include "commons.h"
#include "../AtnHbaFieldDriver_Atena/atnhbafielddriver_atena.h"
#include "../AtnHbaFieldDriver_Atena/RtObjects/pdsx/abstractpdsx.h";

class Mod_notifications: public AbstractModuleBase
{
        Q_OBJECT
private:
    void Init();
    QMap<int, AbstractPdsx *> *m_ListPdsX;

public:
    Mod_notifications();
    ~Mod_notifications();

    void startLoadProcedure();

    QList<notificationTrigger *> triggers;
    bool Start();
    bool Stop();
    void LoadSingleFile(QString filename);
    bool LoadConfiguration(QJsonObject objCfg);
    void setListPdsx(QMap<int, AbstractPdsx *> *pdslist);

public slots:
    void processGUIrequest();
    void parseNotifications();

signals:
    void broadcastMessage(QString message);

};

#endif // MOD_NOTIFICATIONS_H
