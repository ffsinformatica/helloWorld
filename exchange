#ifndef MOD_FIELDMAP_H
#define MOD_FIELDMAP_H


#include <QMap>
#include <QDebug>
#include <QFile>
#include <QJsonArray>
#include <QTimer>

#include "tag.h"
#include "../../Interfaces/abstractobjectjsonserialization.h"
#include "../../Interfaces/abstractpersistence.h"
#include "../../Interfaces/guipoints.h"
#include "../../Modules/AbstractModuleBase.h"
#include "queuebase.h"
#include "tagcommand.h"
#include "../../Interfaces/abstractfielddriver.h"
#include "fieldcommands.h"
#include "../AtnHbaFieldDriver_Atena/RtObjects/pdsx/abstractpdsx.h";

#define XML_DOC_NAME        "FieldMap"
#define XML_ROOT_NAME       "FieldMap"
#define XML_ROOT_OBJ        "Objects"
#define XML_TAG_OBJECT      "Tag"

/**
 * @brief The Mod_FieldMap class
 *
 *
 * Classe di gestione
 *
 *
 */
class Mod_FieldMap: public AbstractModuleBase, public QueueBase, public GuiPoints
{

    Q_OBJECT

private:
    QMap<QString, Tag * > m_TagsField;              // Fieldmap con i dati di campo
    QMap<QString, Tag * > m_TagsSystem;             // Fieldmap con i tag automatici creati dal sistema      (NOT IMPLEMENTED)
    QTimer m_CheckTimer;

    QList<AbstractFieldDriver *> m_Drivers;     // List of drivers

    bool b_AutoCreateMap;                       // Indica al sistema se deve partire in automatico

    QMap<int, AbstractPdsx *> *m_ListPdsX;


    void ConnectTagSignals(Tag * tag);
    Tag *CreateTag(QString key, int mode, int type);
    Tag *CreateTag(QString key, int mode, int type, QMap<QString, QString> *params, AbstractInterface *ifc, int dir, QString driverstr);
    Tag *CreateTag(QJsonObject node);

    void CreateDrivers();
    void StartDrivers();
    void StopDrivers();

    void CheckFolders();
    bool LoadConfiguration(QJsonObject objCfg);

    void StartCheckTimer();

public:
    /**
     * @brief Instance
     *
     * Singleton implementation
     *
     * @return
     */
    static Mod_FieldMap * &Instance()
    {
        static Mod_FieldMap * objFieldMap = NULL;

        if(objFieldMap == NULL)
            objFieldMap = new Mod_FieldMap();

        return objFieldMap;
    }

    explicit Mod_FieldMap();

    QJsonArray GetUiPoints();
    QJsonArray GetTagListJson();                                       // Recupero lista tag con json
    QJsonArray GetModuleAndSlotListJson();                             // Recupero lista moduli e relaitivi slot con json
    QMap<QString, Tag * > * getTags() { return &m_TagsField;}
    QMap<int, AbstractPdsx *> *getListPdsx();

    Tag * SearchTag(QString key);
    float getTagValue(QString key);

    void Load();
    void Unload();
    void Save();

    /*
     * Setter/Getter AutoCreateMap
     */
    bool getAutoCreateMap();
    void setAutoCreateMap(bool value);

    /*
     * Override AbstractWorker
     */
    bool Start();
    bool Stop();


    QList<GuiState *> * getListInterfaceStates();
    int getFieldConnectionState();

    QString toString();


    void CommandDigitalToggle(QString tag);                                                                                 // Toggle on-->off/off-->on
    void CommandDigitalOn(QString tag, en_Time_Unit_Types_t unit, int time, int delay);                                     // On con ritardo
    void CommandDigitalOff(QString tag, en_Time_Unit_Types_t unit, int time, int delay);                                    // Off con ritardo
    void CommandDigitalPwmOn(QString tag, en_Time_Unit_Types_t unit, int timeon, int timeoff, int repeat, int delay);       // Pwm on con delay
    void CommandDigitalPwmOff(QString tag, en_Time_Unit_Types_t unit, int timeon, int timeoff, int repeat, int delay);      // Pwm off con delay
    void CommandAnalogSet(QString tag, float value);                                                                        // Impostazione valore uscita analogica
    void CommandAnalogFromTo(QString tag, en_Time_Unit_Types_t unit, int timeon, float valueFrom, float valueTo);           // Impostazione rampa uscita analogica
    void CommandLive();                                                                                                     // Stato in vita SINERGIBOX

public slots:
    void slotNewTag(QString key, int mode, int type, QMap<QString, QString> params, AbstractInterface *ifc, int dir, QString driverstr);    // Notifica che deve essere inserita in un nuovo tag (Prevedere di passare tutte le informazioni necessarie a generare un tag
    void slotTagValueChangedFromField(QString tagId, float value);                      // Notifica che il tag ha cambiato valore. Dall'esterno per modificare il valore nella fieldmap
    void slotTagValueChanged(Tag *);                                                    // Notifica che il tag ha cambiato valore. Dal singolo Tag. Serve alla fieldmap per mandare la segnalazione in giro.
    void slotTagStatusChanged(Tag *);                                                   // Notifica che il tag ha cambiato stato. Dal singolo Tag. Serve alla fieldmpa per mandare la segnalazione in giro
    void slotSaveMap();                                                                 // Salvataggio mappa
    void slotGestoreOutput(quint16 IdCan, quint8 slot, quint8 numTrigger, quint8 typeTrigger);

private slots:
    void slotNewQueueMessage(const QList<QByteArray>& message);
    void slotTagCommand(TagCommand command);
    void slotCheckTimer();

signals:
    void sgnlMessageForDriver(QList<QByteArray> &message);
    void sgnlTagCommand(QByteArray command);
    void sgnlTagCommand(TagCommand command);
    //RG 15/09/2017 segnale verso field driver per comandi 'al di fuori' dell'astrazione basata sui tag
    void sgnlFieldCommand(en_Field_Command_Types_t fieldcommand);
    void sgnlGestoreOutput(quint16 IdCan, quint8 slot, quint8 numTrigger, quint8 typeTrigger);

};

#endif  // MOD_FIELDMAP_H
